---
name: project-rediscovery
description: |
  系统性重新了解一个遗忘或陌生的项目。通过结构化问答流程，帮助开发者快速恢复对项目的
  完整认知。适用场景：(1) 半年以上没接触的项目需要继续开发，(2) 接手他人的项目需要快速上手，
  (3) 用户说"我忘了这个项目怎么回事"、"帮我重新了解这个项目"、"梳理一下这个项目"。
  核心方法：先问再扫，逐层深入，边问边确认，最终输出结构化文档。
  触发词：了解项目、梳理项目、重新熟悉、项目概览、项目是什么、忘了业务细节。
author: Claude Code
version: 1.0.0
date: 2026-02-06
tags: [project-understanding, onboarding, codebase-discovery]
---

# Project Rediscovery — 项目重新认知方法论

## 核心原则

**先问再扫，逐层深入，边问边确认。**

不要一开始就全面扫描代码。先从用户的模糊记忆出发，获取线索和锚点，再针对性地扫描代码进行确认和补全。这样既尊重用户已有的认知，又能高效地填补空白。

---

## 执行流程

### 第一层：定位（1-2 个问题）

**目标**：确定项目是什么、解决什么问题。

1. **问**：这个项目是用来做什么的？核心场景是什么？
   - 如果用户完全想不起来，先扫描代码帮用户回忆
   - 如果用户有模糊记忆，基于记忆扫描代码确认

2. **扫描确认**：
   - 项目模块结构（Maven/Gradle 模块划分）
   - 核心实体类（DO/Entity）
   - 主要 Controller（API 入口）
   - 外部系统集成（第三方服务）
   - 数据库表（SQL 文件或 ORM 映射）

3. **输出**：向用户确认核心定位，补充遗漏部分

> **关键**：如果是二开项目，必须区分哪些是原框架的代码，哪些是实际业务代码。
> 识别方法：问用户、看 git 历史、看表是否被复用（字段与业务不符）。

---

### 第二层：框架（2-3 个问题）

**目标**：确定项目的整体骨架。

4. **问**：项目当前的开发状态？（已上线 / 开发中 / 暂停）
   - 这决定了后续重点是"理解现有功能"还是"梳理待完成事项"

5. **问**：前端有哪些端？（小程序 / H5 / App / 后台管理）
   - 扫描代码确认：登录方式枚举、平台枚举、Controller 接口前缀

6. **问**：目前在联调/使用的是哪个端？
   - 确定后续要重点关注的业务范围

7. **输出**：整体框架确认（技术栈 + 前端端口 + 开发状态）

---

### 第三层：深入（每个核心模块 1 轮）

**目标**：逐个模块深入了解业务细节和完成度。

对每个核心模块执行以下分析：

```
模块分析模板：
├── 数据模型：涉及哪些表、关键字段
├── 业务流程：完整的步骤流程图
├── 代码路径：关键 Service/Controller 位置
├── 完成度：✅已完成 / ⚠️部分完成 / ❌未实现
└── 遗留问题：已知 bug、缺失逻辑、潜在风险
```

**深入顺序**：
1. 先分析用户当前在联调/关注的模块
2. 再分析与之强关联的模块
3. 最后分析辅助模块

**每分析完一个模块，问用户**：
- 对这个模块的理解是否有补充？
- 是否有我遗漏的业务规则？
- 还有什么模块想深入了解？

---

### 第四层：输出文档

**目标**：将所有信息整理成一份结构化文档。

**文档原则**：
- 不重复：同一信息只出现一次
- 有重点：用表格快速传达状态，用代码路径方便定位
- 可执行：待完成事项按优先级排列

**文档结构**：

```markdown
# 项目名 — 项目概览

## 一、项目定位
> 一句话说明

## 二、表/数据模型（如有复用需说明映射关系）

## 三、核心业务流程
### 3.1 流程A（含流程图 + 代码位置 + 状态）
### 3.2 流程B
...

## 四、前端对接情况

## 五、模块完成度（表格形式）

## 六、待完成事项清单（P0 / P1 / P2）

## 七、关键配置（环境变量、第三方密钥等）

## 八、代码路径速查（表格形式）
```

---

## 关键技巧

### 问答节奏

- **每次只问一个问题**，不要一次抛出多个问题
- 用户回答后，先确认理解，再问下一个
- 如果用户说"不记得了"，就扫描代码帮他确认
- 如果用户提供了模糊信息，扫描代码后跟用户核对

### 识别二开项目

二开项目有大量"看起来存在但实际没用"的代码，需要区分：
- 看 git 提交历史：用户自己的提交 vs 原框架的代码
- 看表复用：字段名与实际业务不匹配
- 直接问用户：哪些功能是原来的，哪些是你加的

### 完成度判断标准

| 状态 | 判断依据 |
|------|---------|
| ✅ 已完成 | 有完整的业务逻辑，能跑通 |
| ⚠️ 部分完成 | 有代码但逻辑不完整，或关键分支未实现 |
| ❌ 未实现 | 接口空壳、代码注释、TODO、只打日志 |

### 优先级判断标准

| 优先级 | 判断依据 |
|--------|---------|
| 🔴 P0 | 影响核心功能，不做就无法使用 |
| 🟠 P1 | 影响功能完整性，不做会有明显缺陷 |
| 🟡 P2 | 优化项，不影响基本使用 |

---

## 反模式

1. **一上来就全面扫描**：信息量太大，用户无法消化。应该先问再扫。
2. **一次问多个问题**：增加用户认知负担。每次只问一个。
3. **只扫描不确认**：代码不等于业务。必须跟用户确认实际用途。
4. **文档堆砌信息**：重复的内容增加认知负担。每条信息只出现一次。
5. **跳过完成度评估**：用户最需要知道的是"还差什么没做"。
6. **忽略二开背景**：二开项目中大量代码是原框架的，不区分会误导。

---

## 适用场景示例

### 场景1：半年没碰的自己的项目
- 用户有模糊记忆 → 从记忆出发，扫描确认
- 重点：完成度评估 + 待完成事项

### 场景2：接手他人的项目
- 用户完全不了解 → 先全面扫描，再逐层讲解
- 重点：架构理解 + 业务流程

### 场景3：项目交接
- 有人可以问 → 结合问答和代码扫描
- 重点：输出文档供后续参考

---

## References

- [6 Steps to Understanding a Large, Legacy Codebase - Atomic Object](https://spin.atomicobject.com/understand-legacy-codebase/)
- [Developer Onboarding Guide: Day 1 to Week 4 - River](https://rivereditor.com/blogs/write-developer-onboarding-guide-30-days)
- [Using GenAI to understand legacy codebases - Thoughtworks](https://www.thoughtworks.com/en-us/radar/techniques/using-genai-to-understand-legacy-codebases)
- [How to Work With a Large Legacy Codebase Like a Pro - freeCodeCamp](https://www.freecodecamp.org/news/how-to-work-with-a-large-legacy-codebase/)
