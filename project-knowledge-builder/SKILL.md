---
name: project-knowledge-builder
description: |
  扫描项目代码，识别业务逻辑模糊点和噪声区域，自动生成结构化问卷文档（选择题+描述题），
  交由了解项目的人回答后，合成为高质量的项目知识库文档，供 AI 进行精准开发。
  触发词：生成项目知识库、补全知识库、项目问卷、扫描项目问题、知识库构建、
  帮我整理项目知识、生成问题文档、项目模糊点分析。
  适用场景：(1) 新项目接入 AI 开发前的知识准备，(2) 已有项目知识库不完整需要补全，
  (3) 多人协作项目需要统一认知，(4) 希望 AI 对项目有深度理解后再开发。
author: Claude Code
version: 1.0.0
date: 2026-02-21
tags: [knowledge-base, project-analysis, questionnaire, codebase-understanding]
---

# Project Knowledge Builder — 项目知识库构建器

## 核心原则

**扫码出题，人工答题，机器合成。**

AI 不猜测业务意图。通过代码扫描发现"不确定的地方"，把这些不确定转化为精准的问题，让真正了解业务的人来回答。回答的结果与代码事实合成为知识库文档，成为 AI 后续高质量开发的基础。

### 与 project-rediscovery 的关系

| 维度 | project-rediscovery | project-knowledge-builder |
|------|-------------------|--------------------------|
| 交互方式 | 实时对话，Claude 问用户答 | 离线问卷，生成文档给人填写 |
| 适用人群 | 项目本人在场 | 专家不在场，问卷可异步传递 |
| 输出物 | 项目概览文档 | 结构化知识库 + 问卷 + 答案 |
| 目的 | 恢复对项目的认知 | 让 AI 具备项目深度理解力 |
| 可组合 | 可先用 rediscovery 建立基础认知，再用本 skill 深入补全 |  |

---

## 执行流程总览

```
┌─────────────────────────────────────────────────────────────┐
│                    三阶段执行流程                              │
│                                                             │
│  Phase 1: 扫描分析          Phase 2: 问卷生成                 │
│  ┌──────────────┐          ┌──────────────┐                 │
│  │ 项目类型识别   │ ──────→ │ 问题提取与分类 │                 │
│  │ 结构扫描      │          │ 问卷文档生成   │                 │
│  │ 模糊点识别    │          │ 输出 Markdown  │                 │
│  └──────────────┘          └──────┬───────┘                 │
│                                   │                          │
│                          （人工填写回答）                       │
│                                   │                          │
│                            Phase 3: 知识合成                  │
│                           ┌──────────────┐                   │
│                           │ 答案解析      │                   │
│                           │ 代码事实关联   │                   │
│                           │ 知识库文档生成  │                  │
│                           └──────────────┘                   │
└─────────────────────────────────────────────────────────────┘
```

---

## Phase 1：扫描分析

### 1.1 项目类型自动识别

扫描项目根目录，识别项目类型和技术栈：

| 识别标志 | 项目类型 | 深入扫描策略 |
|---------|---------|------------|
| `pom.xml` / `build.gradle` + `src/main/java` | Java 后端 | Spring Boot/Cloud 模式扫描 |
| `pom.xml` / `build.gradle` + `AndroidManifest.xml` | Android | Activity/Fragment/ViewModel 模式扫描 |
| `package.json` + `src/` + (`next.config` / `nuxt.config` / `vite.config`) | 前端 (React/Vue/Next/Nuxt) | 组件树 + 路由 + 状态管理扫描 |
| `package.json` + (`nest-cli.json` / `express` / `koa`) | Node.js 后端 | Controller/Service/Middleware 扫描 |
| `requirements.txt` / `pyproject.toml` / `setup.py` | Python | Django/FastAPI/Flask 模式扫描 |
| `go.mod` | Go | Handler/Service/Repository 扫描 |
| `Cargo.toml` | Rust | Module + Trait 模式扫描 |
| `*.sln` / `*.csproj` | .NET/C# | Controller/Service 模式扫描 |
| `flutter` / `pubspec.yaml` | Flutter | Widget/BLoC/Provider 模式扫描 |
| 多个以上特征共存 | Monorepo / 多模块 | 按子项目分别识别并扫描 |

### 1.2 结构扫描

按项目类型执行对应的结构扫描，提取以下信息：

#### 1.2.1 架构层面

```
扫描清单：
├── 模块/包划分：各模块的职责是什么？边界在哪里？
├── 分层结构：Controller → Service → Repository 是否清晰？
├── 依赖关系：模块间如何调用？是否有循环依赖？
├── 配置管理：环境区分（dev/staging/prod）如何实现？
└── 外部集成：调用了哪些第三方服务/API？
```

#### 1.2.2 数据层面

```
扫描清单：
├── 数据模型：实体类/表结构，字段含义
├── 数据流向：数据从哪来？经过什么处理？到哪去？
├── 状态机：有无状态字段？状态流转规则是什么？
├── 枚举/常量：魔法数字、硬编码字符串、未注释的枚举值
└── 缓存策略：有无缓存？缓存的是什么？失效策略？
```

#### 1.2.3 业务逻辑层面

```
扫描清单：
├── 核心流程：主要的业务操作流程（如下单、支付、审批）
├── 分支逻辑：if-else / switch 的业务含义
├── 权限控制：不同角色能做什么？判断逻辑在哪？
├── 异常处理：业务异常 vs 系统异常，处理策略
└── 定时任务/异步：有哪些后台任务？触发条件是什么？
```

### 1.3 模糊点识别

这是本 skill 的**核心能力**。AI 需要识别以下类型的"不确定性"：

#### 类型 A：命名歧义

```
识别规则：
├── 变量/方法/类名含义不明确（如 handleData, processInfo, doSomething）
├── 缩写无法展开（如 biz, mgr, proc 在上下文中指什么）
├── 同一概念多种命名（如 user/member/account 是否指同一实体）
├── 与业务领域不对应的技术命名
└── 中英文混用导致的理解障碍
```

#### 类型 B：逻辑噪声

```
识别规则：
├── 注释掉的代码块（为什么注释？能删吗？）
├── TODO / FIXME / HACK 标记
├── 空的 catch 块或被吞掉的异常
├── 看似冗余的判断逻辑（是防御性编程还是 bug？）
├── 复制粘贴的代码段（是有意区分还是忘了抽取？）
└── 已弃用但未删除的 API/方法
```

#### 类型 C：隐式业务规则

```
识别规则：
├── 魔法数字/字符串（如 status == 3 表示什么？）
├── 硬编码的业务参数（如价格、费率、限额）
├── 条件组合逻辑（复杂的 && || 组合，业务含义不明）
├── 隐藏在工具类中的业务逻辑
├── 数据库查询中的业务过滤条件
└── 配置文件中含义不明的参数
```

#### 类型 D：架构疑点

```
识别规则：
├── 不符合分层规范的调用（如 Controller 直接操作数据库）
├── 未使用的依赖/模块（是计划中的还是遗留的？）
├── 多种技术方案并存（如既用 MyBatis 又用 JPA）
├── 安全相关的疑点（硬编码密钥、未加密传输）
└── 性能相关的疑点（N+1 查询、未分页的大查询）
```

#### 类型 E：流程断点

```
识别规则：
├── 方法定义了但没有被调用
├── 接口有定义但实现为空或只返回 mock 数据
├── 流程图中缺失的步骤（如有创建无删除）
├── 缺失的错误处理路径
└── 异步操作的回调/结果处理不完整
```

---

## Phase 2：问卷生成

### 2.1 问题类型

#### 选择题（用于有限可能性的判断）

适用场景：状态含义、是/否判断、枚举解释、方案选择

**格式**：
```markdown
### Q1. [模块名] 状态字段 `order.status = 3` 的业务含义是什么？

**代码位置**：`com/example/order/OrderService.java:142`

**上下文**：
​```java
if (order.getStatus() == 3) {
    // 触发退款流程
    refundService.process(order);
}
​```

**选项**：
- [ ] A. 已取消（用户主动取消）
- [ ] B. 已退款（退款流程已完成）
- [ ] C. 退款中（退款流程进行中）
- [ ] D. 已关闭（系统超时自动关闭）
- [ ] E. 其他（请说明）：___________
```

#### 描述题（用于开放性的业务解释）

适用场景：业务流程说明、设计决策原因、历史背景

**格式**：
```markdown
### Q5. [支付模块] 请描述完整的支付流程，包括异常情况的处理

**代码位置**：`com/example/payment/PaymentService.java`

**AI 观察到的流程**：
1. 用户提交支付请求
2. 创建支付记录 (status=0)
3. 调用第三方支付 API
4. ❓ 支付回调处理逻辑不完整
5. ❓ 支付超时如何处理？

**请补充/纠正以上流程**：

_______________________________________
_______________________________________
```

#### 确认题（用于 AI 需要验证猜测的场景）

适用场景：AI 有一定把握但需要确认

**格式**：
```markdown
### Q8. [用户模块] User 和 Member 是否指同一个实体？

**AI 分析**：
- `User` 出现在登录/注册模块，表结构为 `t_user`
- `Member` 出现在会员体系模块，表结构为 `t_member`
- 两者通过 `user_id` 关联
- AI 推测：User = 基础账号，Member = 会员扩展信息

**请确认**：
- [ ] A. AI 分析正确
- [ ] B. 部分正确，补充说明：___________
- [ ] C. 不正确，实际关系是：___________
```

### 2.2 问题组织结构

问卷按以下结构组织：

```markdown
# 项目名称 — 项目知识问卷

> 生成时间：YYYY-MM-DD
> 项目类型：Java Spring Boot 后端
> 扫描范围：全项目 / 指定模块
> 问题总数：N 题（选择题 X 题 + 描述题 Y 题 + 确认题 Z 题）
> 预计填写时间：约 M 分钟

## 填写说明
1. 请尽量回答所有问题，如果某个问题不确定可以标注"不确定"
2. 选择题直接在选项前打 [x] 即可
3. 描述题请尽量详细，越详细 AI 的理解越准确
4. 如果 AI 的分析有误，请直接纠正
5. 可以在任何问题后面追加补充说明

## 一、项目全局（N 题）
### 1.1 项目背景与定位
... 问题 ...
### 1.2 项目状态与规划
... 问题 ...

## 二、架构与技术（N 题）
### 2.1 架构设计决策
... 问题 ...
### 2.2 技术选型原因
... 问题 ...

## 三、核心业务模块（N 题）
### 3.1 模块 A
... 问题 ...
### 3.2 模块 B
... 问题 ...

## 四、数据与状态（N 题）
... 问题 ...

## 五、集成与外部依赖（N 题）
... 问题 ...

## 六、遗留问题与待办（N 题）
... 问题 ...
```

### 2.3 问题生成规则

**优先级排序**：

| 优先级 | 类型 | 说明 |
|-------|------|------|
| P0 | 核心业务流程 | 不理解这些就无法正确开发 |
| P1 | 状态/枚举含义 | 影响逻辑判断的正确性 |
| P2 | 架构决策原因 | 影响扩展和修改方向 |
| P3 | 命名和约定 | 影响代码一致性 |
| P4 | 历史遗留 | 了解背景但不阻塞开发 |

**数量控制**：

- 单次问卷建议 **15-40 题**，不超过 50 题
- 如果模糊点超过 50 个，按优先级分批生成
- 每个模块 3-8 题为宜
- 选择题 : 描述题 : 确认题 ≈ 4 : 3 : 3

**质量要求**：

- 每个问题必须附带**代码位置**（文件路径 + 行号）
- 每个问题必须有**上下文**（代码片段或 AI 观察）
- 选择题的选项必须是**合理且互斥**的
- 不问"显而易见"的问题（如技术栈是什么 → 代码已经表明）
- 不问"无法从人那里获得答案"的问题（如最优架构是什么）

---

## Phase 3：知识合成

### 3.1 答案解析

人工回答问卷后，AI 执行以下步骤：

1. **读取回答文档**：解析填写后的 Markdown 文件
2. **答案验证**：将回答与代码事实交叉验证
   - 回答与代码一致 → 直接纳入知识库
   - 回答与代码矛盾 → 标记为"需要澄清"并输出给用户
   - 回答为"不确定" → 保留为开放问题
3. **关联补全**：基于回答推导出的关联信息（如 A 的回答隐含了 B 的答案）

### 3.2 知识库文档结构

```markdown
# 项目名称 — 项目知识库

> 生成时间：YYYY-MM-DD
> 知识来源：代码扫描 + 人工问卷 v1
> 知识覆盖度：已回答 N/M 题，覆盖 X% 核心模块
> 置信度标记说明：
>   🟢 已确认（人工回答 + 代码验证）
>   🟡 AI 推断（代码分析，未经人工确认）
>   🔴 存疑（回答与代码矛盾，或答案为"不确定"）

---

## 一、项目概述

### 1.1 项目定位
> [一句话说明项目做什么] 🟢

### 1.2 业务领域
> [所属行业/领域] 🟢

### 1.3 项目状态
> [开发中 / 已上线 / 维护中] 🟢

### 1.4 核心用户角色
> [角色列表及其主要操作] 🟢

---

## 二、技术架构

### 2.1 技术栈
| 层级 | 技术 | 版本 | 备注 |
|------|------|------|------|
| ... | ... | ... | ... |

### 2.2 项目结构
​```
项目目录树（标注每个模块的职责）
​```

### 2.3 架构决策记录
| 决策 | 选择 | 原因 | 置信度 |
|------|------|------|--------|
| ORM 框架 | MyBatis | 团队熟悉 + 复杂查询多 | 🟢 |
| ... | ... | ... | ... |

---

## 三、领域模型

### 3.1 核心实体关系
​```
实体关系图（文字版 ER 图）
​```

### 3.2 实体详解
#### 3.2.1 实体名

| 字段 | 类型 | 业务含义 | 备注 | 置信度 |
|------|------|---------|------|--------|
| status | int | 订单状态 | 0=待支付 1=已支付 2=已发货 3=已完成 | 🟢 |
| ... | ... | ... | ... | ... |

---

## 四、核心业务流程

### 4.1 流程名称
**置信度**: 🟢

**完整流程**：
1. 步骤一
2. 步骤二
   - 异常路径 A：...
   - 异常路径 B：...
3. 步骤三

**关键代码位置**：
| 步骤 | 代码位置 |
|------|---------|
| 步骤一 | `com/example/XxxService.java:100` |
| ... | ... |

**业务规则**：
- 规则 1：...
- 规则 2：...

---

## 五、状态机与枚举

### 5.1 订单状态
​```
状态流转图（文字版）
0(待支付) → 1(已支付) → 2(已发货) → 3(已完成)
         ↘ 4(已取消)
​```

### 5.2 枚举值速查表
| 枚举类 | 值 | 含义 | 置信度 |
|--------|---|------|--------|
| OrderStatus.PAID | 1 | 已支付 | 🟢 |
| ... | ... | ... | ... |

---

## 六、外部集成

### 6.1 第三方服务
| 服务 | 用途 | 对接方式 | 关键配置 | 置信度 |
|------|------|---------|---------|--------|
| ... | ... | ... | ... | ... |

---

## 七、权限与安全

### 7.1 角色权限矩阵
| 操作 | 管理员 | 普通用户 | 访客 |
|------|--------|---------|------|
| ... | ✅ | ✅ | ❌ |

---

## 八、开放问题（未解决）

以下问题尚未得到明确回答，开发时需注意：

| # | 问题 | 关联代码 | 影响范围 |
|---|------|---------|---------|
| 1 | ... | ... | ... |

---

## 九、AI 开发指南

### 9.1 开发时必须遵守的业务规则
1. ...
2. ...

### 9.2 容易踩的坑
1. ...
2. ...

### 9.3 命名约定
| 概念 | 代码命名 | 业务含义 |
|------|---------|---------|
| 用户 | User | 基础账号信息 |
| 会员 | Member | 会员体系扩展 |
| ... | ... | ... |

### 9.4 待开发功能的建议实现方式
| 功能 | 建议方案 | 原因 |
|------|---------|------|
| ... | ... | ... |
```

---

## 多语言项目扫描策略

### Java 后端（Spring Boot / Spring Cloud）

```
扫描入口：
├── pom.xml / build.gradle → 依赖分析（Spring 版本、中间件）
├── application.yml / application.properties → 配置分析
├── @SpringBootApplication 入口类 → 包扫描范围
│
├── 架构层：
│   ├── @Controller / @RestController → API 入口清单
│   ├── @Service → 业务逻辑层
│   ├── @Repository / Mapper → 数据访问层
│   ├── @Configuration → 配置类
│   └── @Component → 工具类/监听器
│
├── 业务层：
│   ├── Entity / DO / PO → 数据模型
│   ├── DTO / VO / BO → 数据传输对象
│   ├── Enum → 枚举定义
│   ├── Exception → 自定义异常
│   └── Constant → 常量定义
│
├── 模糊点识别重点：
│   ├── @Transactional 的传播行为和隔离级别
│   ├── 自定义注解的业务含义
│   ├── AOP 切面隐藏的逻辑
│   ├── 配置文件中的业务参数
│   ├── SQL 中的复杂查询条件
│   └── 多数据源/分库分表策略
│
└── 特殊关注：
    ├── Feign/RestTemplate 远程调用
    ├── MQ 消息的发送和消费
    ├── 定时任务 @Scheduled / Quartz
    └── 缓存注解 @Cacheable 的 key 策略
```

### Android（Kotlin / Java）

```
扫描入口：
├── AndroidManifest.xml → 权限、组件注册、入口 Activity
├── build.gradle → 依赖、SDK 版本、构建变体
├── app/src/main/ → 主要代码目录
│
├── 架构层：
│   ├── Activity / Fragment → 页面入口
│   ├── ViewModel / Presenter → 业务逻辑
│   ├── Repository → 数据仓库
│   ├── Room / SQLite → 本地数据库
│   └── Retrofit / OkHttp → 网络请求
│
├── UI 层：
│   ├── res/layout/ → 页面布局
│   ├── res/navigation/ → 导航图
│   ├── Adapter / ViewHolder → 列表相关
│   └── 自定义 View → 特殊 UI 组件
│
├── 模糊点识别重点：
│   ├── Intent 传递的数据和跳转逻辑
│   ├── 生命周期相关的业务处理
│   ├── 后台任务 (WorkManager / Service)
│   ├── 推送通知的处理逻辑
│   ├── 多渠道/多变体的差异
│   └── 权限请求的时机和降级逻辑
│
└── 特殊关注：
    ├── DeepLink / App Link 路由
    ├── 第三方 SDK 初始化和回调
    ├── 混淆规则 proguard-rules.pro
    └── 多进程场景
```

### 前端（React / Vue / Next.js / Nuxt）

```
扫描入口：
├── package.json → 依赖分析（框架版本、UI 库、状态管理）
├── 配置文件 → next.config / nuxt.config / vite.config
├── src/ or app/ → 主要代码目录
│
├── 架构层：
│   ├── pages/ or app/ → 路由结构
│   ├── components/ → 组件树
│   ├── store/ or context/ → 状态管理
│   ├── hooks/ or composables/ → 逻辑复用
│   ├── services/ or api/ → 接口调用
│   └── utils/ or lib/ → 工具函数
│
├── 业务层：
│   ├── 路由守卫/中间件 → 权限控制
│   ├── 表单组件 → 校验规则和提交逻辑
│   ├── 列表/表格 → 筛选、排序、分页逻辑
│   └── 弹窗/抽屉 → 操作流程
│
├── 模糊点识别重点：
│   ├── 组件 props 的业务含义（尤其是 boolean flag）
│   ├── 状态管理中的业务状态 vs UI 状态
│   ├── 接口调用的错误处理和 loading 状态
│   ├── 权限控制的粒度（页面级 / 按钮级）
│   ├── 环境变量的用途
│   └── SSR / CSR 的选择原因
│
└── 特殊关注：
    ├── 国际化 (i18n) 的范围
    ├── 主题/暗黑模式的实现
    ├── 微前端/模块联邦
    └── 性能优化策略（懒加载、缓存）
```

### Node.js 后端（Express / NestJS / Koa）

```
扫描入口：
├── package.json → 依赖分析
├── 入口文件 (index.ts / main.ts / app.ts)
├── 配置 (.env / config/)
│
├── 架构层：
│   ├── Routes / Controllers → API 入口
│   ├── Services → 业务逻辑
│   ├── Models / Schemas → 数据模型 (Mongoose / Sequelize / Prisma)
│   ├── Middleware → 中间件链
│   └── Guards / Pipes (NestJS) → 验证和转换
│
├── 模糊点识别重点：
│   ├── 中间件的执行顺序和职责
│   ├── 认证/授权的实现方式
│   ├── 数据校验的规则和位置
│   ├── 文件上传/流处理逻辑
│   └── WebSocket 事件的业务含义
│
└── 特殊关注：
    ├── ORM 关系定义 (hasMany, belongsTo)
    ├── Migration 文件的业务背景
    ├── 队列任务 (Bull / BullMQ)
    └── GraphQL Schema (如有)
```

### Python 后端（Django / FastAPI / Flask）

```
扫描入口：
├── requirements.txt / pyproject.toml → 依赖分析
├── manage.py / main.py → 入口文件
├── settings.py / .env → 配置
│
├── 架构层（Django）：
│   ├── models.py → 数据模型
│   ├── views.py / viewsets.py → 视图层
│   ├── serializers.py → 序列化
│   ├── urls.py → 路由
│   ├── admin.py → 后台管理配置
│   └── signals.py → 信号处理
│
├── 架构层（FastAPI）：
│   ├── routers/ → 路由
│   ├── schemas/ → Pydantic 模型
│   ├── models/ → ORM 模型
│   ├── services/ → 业务逻辑
│   └── dependencies/ → 依赖注入
│
├── 模糊点识别重点：
│   ├── Django Signal 触发的隐式逻辑
│   ├── Celery Task 的业务含义
│   ├── Model Manager 的自定义查询
│   ├── Middleware 的处理逻辑
│   └── 权限类 (Permission Classes) 的规则
│
└── 特殊关注：
    ├── Migration 历史和数据迁移
    ├── Management Commands
    ├── 第三方 App 的集成方式
    └── 异步视图 (async views) 的使用场景
```

### Go 后端

```
扫描入口：
├── go.mod → 依赖分析
├── main.go / cmd/ → 入口
├── internal/ or pkg/ → 代码组织
│
├── 架构层：
│   ├── handler/ or controller/ → HTTP 处理
│   ├── service/ → 业务逻辑
│   ├── repository/ or dao/ → 数据访问
│   ├── model/ or entity/ → 数据结构
│   ├── middleware/ → 中间件
│   └── router/ → 路由注册
│
├── 模糊点识别重点：
│   ├── interface 定义的业务抽象
│   ├── goroutine 的并发逻辑
│   ├── channel 的数据传递含义
│   ├── context 的传播和取消逻辑
│   └── error wrapping 的层级
│
└── 特殊关注：
    ├── wire / fx 依赖注入
    ├── protobuf / gRPC 定义
    ├── 配置热更新
    └── 优雅关停逻辑
```

---

## 增量模式（知识库补全）

当项目已有知识库文档时，执行增量更新：

### 补全流程

```
1. 读取已有知识库文档
2. 扫描代码变更（git diff 或全量重扫）
3. 识别新增的模糊点（排除已覆盖的）
4. 只针对新增部分生成问卷
5. 合并回答到已有知识库
```

### 增量扫描触发条件

- 用户说"补全知识库"
- 发现知识库中有 🟡 或 🔴 标记的条目
- 代码有较大变更（新增模块/重构）
- 用户指定某个模块需要深入

### 增量问卷标记

```markdown
# 项目名称 — 知识库补全问卷 (v2)

> 上次问卷时间：YYYY-MM-DD
> 本次补全原因：新增支付模块 + 3个 🔴 待澄清项
> 新增问题：8 题
> 待澄清：3 题（来自 v1 的矛盾项）
```

---

## 执行细节

### 启动指令处理

用户触发 skill 后，先确认以下信息：

```
1. 是生成新的知识库还是补全已有的？
   → 检查项目中是否已有知识库文档

2. 扫描范围是什么？
   → 全项目 / 指定模块 / 指定文件

3. 问卷输出位置？
   → 默认：项目根目录/docs/knowledge/questionnaire-vN.md
   → 知识库：项目根目录/docs/knowledge/knowledge-base.md
```

### 文件输出约定

```
项目根目录/
└── docs/
    └── knowledge/
        ├── questionnaire-v1.md          # 第一次问卷
        ├── questionnaire-v1-answered.md  # 回答后的问卷（人工填写）
        ├── questionnaire-v2.md          # 增量问卷
        ├── knowledge-base.md            # 知识库文档（持续更新）
        └── open-questions.md            # 开放问题汇总
```

### 问卷填写引导

生成问卷后，输出以下引导信息给用户：

```
问卷已生成：docs/knowledge/questionnaire-v1.md

📋 共 N 题（选择题 X + 描述题 Y + 确认题 Z）
⏱ 预计填写时间：约 M 分钟

请将问卷交给了解此项目的人填写。填写完成后：
1. 将填写好的文件保存为 questionnaire-v1-answered.md（或直接在原文件上填写）
2. 告诉我"问卷填好了"或"合成知识库"
3. 我会读取答案并生成/更新知识库文档
```

---

## 质量检查清单

### 问卷质量

- [ ] 每个问题都有明确的代码位置引用
- [ ] 选择题的选项互斥且合理
- [ ] 描述题有足够的上下文帮助回答者理解
- [ ] 没有问"能从代码直接得出答案"的问题
- [ ] 问题按模块和优先级组织
- [ ] 总题数在合理范围内（15-40 题）

### 知识库质量

- [ ] 每条知识都标注了置信度（🟢🟡🔴）
- [ ] 代码位置引用准确
- [ ] 没有与代码矛盾的描述
- [ ] 开放问题单独列出
- [ ] AI 开发指南可直接指导开发
- [ ] 枚举和状态值完整列出

---

## 反模式

1. **AI 自己猜答案写入知识库**：不确定的就问，不要猜。用 🟡 标记推断，用 🔴 标记矛盾。
2. **问题太宽泛**：如"这个项目是怎么设计的？" → 应该拆成具体的、可回答的小问题。
3. **忽略代码上下文**：问题没有附代码片段，回答者不知道在问什么。
4. **问卷太长**：超过 50 题回答者会疲劳。按优先级分批。
5. **只问不验证**：收到回答后不与代码交叉验证，可能纳入错误信息。
6. **知识库不更新**：代码变了知识库没跟着更新，比没有知识库更危险。
7. **忽略增量场景**：每次都从头生成问卷，浪费回答者时间。

---

## 使用示例

### 示例 1：全新项目首次构建知识库

```
用户：帮我生成这个项目的知识库
AI：  检测到这是一个 Java Spring Boot 项目，目前没有知识库文档。
     我来扫描项目并生成知识问卷...

     [扫描中...]

     问卷已生成：docs/knowledge/questionnaire-v1.md
     共 28 题，预计填写时间 20 分钟。
     请交给了解项目的人填写。

---（人工填写后）---

用户：问卷填好了
AI：  读取答案中...发现 2 处回答与代码有矛盾，已标记为 🔴。
     知识库已生成：docs/knowledge/knowledge-base.md
     覆盖 85% 核心模块，3 个开放问题待后续确认。
```

### 示例 2：补全已有知识库

```
用户：补全一下知识库，最近加了支付模块
AI：  读取已有知识库...扫描代码变更...
     发现新增支付模块（8 个 Service、12 个 API），以及 2 个 🔴 待澄清项。

     增量问卷已生成：docs/knowledge/questionnaire-v2.md
     共 12 题（新增 10 + 待澄清 2）。
```

### 示例 3：指定模块深度扫描

```
用户：帮我把订单模块的知识整理一下
AI：  聚焦扫描订单模块...

     发现 5 个状态字段含义不明确，3 个复杂业务流程缺少说明。
     问卷已生成，共 15 题。
```
